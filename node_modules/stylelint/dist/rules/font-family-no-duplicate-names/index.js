"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.messages = exports.ruleName = undefined;

exports.default = function (actual) {
  return function (root, result) {
    var validOptions = (0, _utils.validateOptions)(result, ruleName, { actual: actual });
    if (!validOptions) {
      return;
    }

    root.walkDecls(/^font(-family)?$/i, function (decl) {
      var keywords = new Set();
      var familyNames = new Set();

      var fontFamilies = (0, _utils.findFontFamily)(decl.value);

      if (fontFamilies.length === 0) {
        return;
      }

      fontFamilies.forEach(function (fontFamilyNode) {
        if (isFamilyNameKeyword(fontFamilyNode)) {
          var _family = fontFamilyNode.value.toLowerCase();

          if (keywords.has(_family)) {
            complain(messages.rejected(_family), (0, _utils.declarationValueIndex)(decl) + fontFamilyNode.sourceIndex, decl);
            return;
          }

          keywords.add(_family);
          return;
        }

        var family = fontFamilyNode.value.trim();

        if (familyNames.has(family)) {
          complain(messages.rejected(family), (0, _utils.declarationValueIndex)(decl) + fontFamilyNode.sourceIndex, decl);
          return;
        }

        familyNames.add(family);
      });
    });

    function complain(message, index, decl) {
      (0, _utils.report)({
        result: result,
        ruleName: ruleName,
        message: message,
        node: decl,
        index: index
      });
    }
  };
};

var _utils = require("../../utils");

var _keywordSets = require("../../reference/keywordSets");

var ruleName = exports.ruleName = "font-family-no-duplicate-names";

var messages = exports.messages = (0, _utils.ruleMessages)(ruleName, {
  rejected: function rejected(name) {
    return "Unexpected duplicate name " + name;
  }
});

var isFamilyNameKeyword = function isFamilyNameKeyword(node) {
  return !node.quote && _keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());
};